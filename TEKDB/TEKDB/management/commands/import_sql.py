from django.core.management.base import BaseCommand, CommandError
from TEKDB.models import *
import os
import sys
from TEKDB.settings import *
from django.utils import timezone
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from django import db

class Command(BaseCommand):

    help = 'Imports and rearranges SQL for PostgreSQL generated by Bullzip from Access DB'

    def add_arguments(self, parser):
        parser.add_argument('infile', nargs='+', type=str)

    def create_groups(self):
        admin_group, created = Group.objects.get_or_create(name='Administrator')
        admin_group_id = admin_group.id
        edit_group, created = Group.objects.get_or_create(name='Editor')
        edit_group_id = edit_group.id
        read_group, created = Group.objects.get_or_create(name='Reader')
        read_group_id = read_group.id
        admin_add_perms = Permission.objects.all()
        admin_group.permissions.set(admin_add_perms)
        from django.db.models import Q
        cts = ContentType.objects.filter(
            Q(app_label='TEKDB') |
            Q(app_label='Relationships')
        )
        edit_add_perms = Permission.objects.filter(content_type__in=cts)
        edit_group.permissions.set(edit_add_perms)
        return {
            'admin_id': admin_group_id,
            'edit_id': edit_group_id,
            'read_id': read_group_id
        }

    def get_model_list(self):
        return [
            'LookupPlanningUnit',
            'LookupTribe',
            'LookupHabitat',
            'Places',
            'LookupResourceGroup',
            'Resources',
            'LookupPartUsed',
            'LookupCustomaryUse',
            'LookupSeason',
            'LookupTiming',
            'PlacesResourceEvents',
            'LookupParticipants',
            'LookupTechniques',
            'LookupActivity',
            'ResourcesActivityEvents',
            'People',
            'LookupReferenceType',
            'LookupAuthorType',
            'Citations',
            'PlacesCitationEvents',
            'CurrentVersion',
            'LookupLocalityType',
            'Locality',
            'LocalityGISSelections',
            'LocalityPlaceResourceEvent',
            'LookupMediaType',
            'LookupUserInfo',
            'Media',
            'MediaCitationEvents',
            'PlaceAltIndigenousName',
            'PlaceGISSelections',
            'PlacesMediaEvents',
            'PlacesResourceCitationEvents',
            'PlacesResourceMediaEvents',
            'ResourceActivityCitationEvents',
            'ResourceActivityMediaEvents',
            'ResourceAltIndigenousName',
            'ResourceResourceEvents',
            'ResourcesCitationEvents',
            'ResourcesMediaEvents',
            'UserAccess',
            'Users',
        ]

    def create_sql_dict(self,infile):
        import string
        import re
        import shlex
        now = timezone.now()
        ############################################
        print("Generating insert script")
        ############################################
        insert_dict = {}
        model_list = self.get_model_list()
        group_id_dict = self.create_groups()
        # create lookup indexes (all 0)
        lookups = [
            # 'LookupPlanningUnit',     #Already has a numeric auto pk
            # 'LookupTribe',            #Already has a numeric auto pk
            'LookupHabitat',
            'LookupResourceGroup',
            'LookupPartUsed',
            'LookupCustomaryUse',
            'LookupSeason',
            'LookupTiming',
            'LookupParticipants',
            'LookupTechniques',
            'LookupActivity',
            'LookupReferenceType',
            'LookupAuthorType',
            'LookupLocalityType',
            'LookupMediaType',
            # 'LookupUserInfo',         #Not used as an FK anywhere
        ]
        lookup_pks = {
            # 'LookupPlanningUnit': '"PlanningUnitID"',   #Already has a numeric auto pk
            # 'LookupTribe': '"ID"',                      #Already has a numeric auto pk
            'LookupHabitat': '"Habitat"',
            'LookupResourceGroup': '"ResourceClassificationGroup"',
            'LookupPartUsed': '"PartUsed"',
            'LookupCustomaryUse': '"UsedFor"',
            'LookupSeason': '"Season"',
            'LookupTiming': '"Timing"',
            'LookupParticipants': '"Participants"',
            'LookupTechniques': '"Techniques"',
            'LookupActivity': '"Activity"',
            'LookupReferenceType': '"DocumentType"',
            'LookupAuthorType': '"AuthorType"',
            'LookupLocalityType': '"LocalityType"',
            'LookupMediaType': '"MediaType"',
            # 'LookupUserInfo': '"pk"',                   #Not used as an FK anywhere
        }
        lookup_indices = {}
        # create lookup dict
        lookup_values = {}
        for lookup in lookups:
            lookup_indices[lookup] = 0
            lookup_values[lookup] = {
                'NULL': 'NULL'
            }
            # { 'Rocky Shore': 7 }
        # create list of models with lookup dependencies
        lookup_dependencies = {
            'Citations': {
                '"ReferenceType"': 'LookupReferenceType',
                '"AuthorType"': 'LookupAuthorType'
            },
            'Locality': {
                '"LocalityType"': 'LookupLocalityType'
            },
            'Media': {
                '"MediaType"': 'LookupMediaType'
            },
            'Places': {
                '"PrimaryHabitat"': 'LookupHabitat',
            },
            'PlacesResourceEvents': {
                '"PartUsed"': 'LookupPartUsed',
                '"CustomaryUse"': 'LookupCustomaryUse',
                '"Season"': 'LookupSeason',
                '"Timing"': 'LookupTiming'
            },
            'Resources': {
                '"ResourceClassificationGroup"': 'LookupResourceGroup',
            },
            'ResourcesActivityEvents': {
                '"PartUsed"': 'LookupPartUsed',
                '"Timing"': 'LookupTiming',
                '"Participants"': 'LookupParticipants',
                '"Technique"': 'LookupTechniques',
                '"ActivityShortDescription"': 'LookupActivity',
            }
        }
        for model in model_list:
            insert_dict[model] = {
                'inserts': [],
                'selects': [],
                'indices': [],
            }
        with open(infile) as rf:
            for line in rf:
                if "INSERT INTO \"" in line:
                    pattern = re.compile(r'INSERT INTO "(?P<table>.*)" \((?P<columns>.*)\) VALUES \((?P<values>.*)\);')
                    result = pattern.match(line)
                    model = result.groupdict()['table']
                    columns_lex = shlex.shlex(result.groupdict()['columns'])
                    columns_lex.quotes = '"'
                    columns = list(columns_lex)
                    columns = list(filter((',').__ne__, columns))
                    values = re.findall(r'(E\'".+?(?!\\)"\'|E\'.*?(?!\\)\'|.+?)(?:,\s|$)', result.groupdict()['values'])
                    if len(columns) != len(values):
                        import ipdb
                        ipdb.set_trace()
                        # This is left in place so that any detected mismatches can be fixed by hand now.
                        print(values)


                    if model == "Users":
                        columns = columns + ['"is_superuser"', '"is_staff"', '"is_active"', '"date_joined"']
                        values = values + ["E'0'", "E'0'", "E'1'", "'%s'" % str(now)]
                    elif model == "UserAccess":
                        accessLevelIndex = columns.index('"AccessLevel"')
                        if values[accessLevelIndex] == "E'Administrator'" :
                            group_id = group_id_dict['admin_id']
                        elif values[accessLevelIndex] == "E'Editor'":
                            group_id = group_id_dict['edit_id']
                        else:
                            group_id = group_id_dict['read_id']
                        columns = columns + ['"group_id"']
                        values = values + [str(group_id)]
                    if model in lookups:
                        record_id = lookup_indices[model]
                        pk_field = lookup_pks[model]
                        columns = columns + ['"id"']
                        values = values + [str(record_id)]
                        try:
                            pk_index = columns.index(pk_field)
                        except Exception:
                            import ipdb
                            ipdb.set_trace()
                        pk_value = values[pk_index]
                        if not pk_value in lookup_values[model].keys():
                            lookup_values[model][pk_value] = str(record_id)
                            lookup_indices[model] = record_id + 1

                    insert_dict[model]['inserts'].append({
                        'table': model,
                        'columns': columns,
                        'values': values
                    })
                elif "SELECT setval(" in line:
                    # SELECT setval('"Users_UserID_seq"', MAX("UserID")) FROM "Users";
                    pattern = re.compile(r'SELECT setval\(\'(?P<sequence>.*)\', MAX\((?P<column>.*)\)\) FROM "(?P<table>.*)";')
                    result = pattern.match(line)
                    model = result.groupdict()['table']
                    column = result.groupdict()['column']
                    sequence = result.groupdict()['sequence']
                    insert_dict[model]['selects'].append({
                        'sequence': sequence,
                        'table': model,
                        'column': column
                    })
                elif "CREATE INDEX " in line:
                    # CREATE INDEX "Users_UserID" ON "Users" ("UserID");
                    pattern = re.compile(r'CREATE INDEX "(?P<index>.*)" ON "(?P<table>.*)" \((?P<columns>.*)\);')
                    result = pattern.match(line)
                    model = result.groupdict()['table']
                    columns = result.groupdict()['columns']
                    index = result.groupdict()['index']
                    insert_dict[model]['indices'].append({
                        'index': index,
                        'table': model,
                        'columns': columns
                    })

        #TODO: when done:
        #TODO:      For each user:
        #TODO:          Check access-level and adjust 'is_superuser' and 'is_staff' accordingly
        #TODO:          or see that groups are appropriate

        for model in lookup_dependencies.keys():
            for insert_rec in insert_dict[model]['inserts']:
                for lookup in lookup_dependencies[model].keys():
                    # get index of lookup fk field
                    lookup_index = insert_rec['columns'].index(lookup)
                    # get old char pk value for fk lookup model
                    char_pk_value = insert_rec['values'][lookup_index]
                    # get model of lookup fk
                    lookup_model = lookup_dependencies[model][lookup]
                    # Check to be sure lookup_value exists and has an associated ID
                    if not char_pk_value in lookup_values[lookup_model].keys():
                        lookup_record_id = lookup_indices[lookup_model]
                        lookup_values[lookup_model][char_pk_value] = str(lookup_record_id)
                        lookup_indices[lookup_model] = lookup_record_id + 1
                        insert_dict[lookup_model]['inserts'].append({
                            'table': lookup_model,
                            'columns': ['"id"', lookup_pks[lookup_model]],
                            'values': [str(lookup_record_id), char_pk_value]
                        })
                    # get int pk value from old char pk value
                    lookup_id = lookup_values[lookup_model][char_pk_value]
                    insert_rec['values'][lookup_index] = lookup_id
        return insert_dict

    def create_insert_script(self, insert_script,insert_dict):
        model_list = self.get_model_list()
        with open(insert_script, "w") as wf:
            for model in model_list:
                for insert in insert_dict[model]['inserts']:
                    line = 'INSERT INTO "%s" (%s) VALUES (%s);\n' % (insert['table'], ', '.join(insert['columns']), ', '.join(insert['values']))
                    wf.write(line)
                for select in insert_dict[model]['selects']:
                    line = 'SELECT setval(\'%s\', MAX(%s)) FROM "%s";\n' % (select['sequence'], select['column'], select['table'])
                    wf.write(line)
                for index in insert_dict[model]['indices']:
                    line = 'CREATE INDEX "%s" ON "%s" (%s);\n' % (index['index'], index['table'], index['columns'])
                    wf.write(line)


    def get_app_list(self):
        return ['TEKDB', 'Lookup', 'Accounts', 'Relationships', 'explore']

    def revert_migrations(self, manage_py):
        ############################################
        print("Reverting migrations")
        ############################################
        for app_module in self.get_app_list():
            os.system("%s migrate --fake %s zero" % (manage_py, app_module))

    def delete_old_migrations(self, MANAGE_DIR):
        ############################################
        print("Deleting migration files...")
        ############################################
        from pathlib import Path
        for module in self.get_app_list():
            migrations_path = os.path.join(MANAGE_DIR,module,'migrations')
            migrations = Path(migrations_path)
            migration_files = [x for x in migrations.iterdir() if not x.name == '__init__.py' and not x.is_dir()]
            for migration_file in migration_files:
                try:
                    os.remove(str(migration_file))
                    print('%s deleted' % migration_file.name)
                except OSError as e:
                    pass

    def rebuild_db(self, dbname, manage_py):
        ############################################
        print("Dropping Database")
        ############################################
        import psycopg2
        db.connections.close_all()
        conn_psql = psycopg2.connect("dbname=postgres user=postgres")
        cur_psql = conn_psql.cursor()
        conn_psql.set_isolation_level(0)
        cur_psql.execute('DROP DATABASE if exists %s;' % dbname)
        print("Recreating Database")
        cur_psql.execute('CREATE DATABASE %s;' % dbname)
        cur_psql.close()
        conn_psql.close()

        ############################################
        print("Making updated migration files")
        ############################################
        os.system("%s makemigrations" % manage_py)

        ############################################
        print("Migrating database")
        ############################################
        os.system("%s migrate" % manage_py)

    def import_sql_data(self,import_output,import_error,dbname,insert_script):
        ############################################
        print("Transferring old data into new database")
        ############################################
        from subprocess import Popen, PIPE
        out = open(import_output, 'w')
        sys.stdout = out
        error = open(import_error, 'w')

        p = Popen(['psql', '-U', 'postgres', '-d', dbname, '-f', insert_script], stdout=out)#, stderr=error)
        p.wait()

        ############################################
        # Setting Passwords
        ############################################
        from TEKDB.models import Users
        users = Users.objects.all()
        for user in users:
            user.set_password(user.password)
            if user.accesslevel.accesslevel == 'Administrator':
                user.is_superuser = True
                user.is_staff = True
            if user.accesslevel.accesslevel == 'Editor':
                user.is_staff = True
            user.save()

    def handle(self, *args, **options):
        FILE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        MANAGE_DIR = os.path.join(FILE_DIR,'..','..')
        infile = os.path.join(MANAGE_DIR, options['infile'][0])
        insert_script = os.path.join('scripts','insert.sql')
        import_output = os.path.join('scripts','import_output.txt')
        import_error = os.path.join('scripts','import_output.txt')
        manage_py = os.path.join(MANAGE_DIR, 'manage.py')

        self.revert_migrations(manage_py)
        self.delete_old_migrations(MANAGE_DIR)
        dbname = 'tekdb'
        self.rebuild_db(dbname, manage_py)

        insert_dict = self.create_sql_dict(infile)
        self.create_insert_script(insert_script,insert_dict)

        self.import_sql_data(import_output,import_error,dbname,insert_script)
