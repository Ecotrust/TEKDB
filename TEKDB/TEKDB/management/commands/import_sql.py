from django.core.management.base import BaseCommand, CommandError
from TEKDB.models import *
import os, sys
from TEKDB.settings import *
from django.utils import timezone
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from django import db

class Command(BaseCommand):

    help = 'Imports and rearranges SQL for PostgreSQL generated by Bullzip from Access DB'

    def add_arguments(self, parser):
        parser.add_argument('infile', nargs='+', type=str)
        parser.add_argument('revert', nargs='*', type=bool)

    def create_groups(self):
        admin_group, created = Group.objects.get_or_create(name='Administrator')
        admin_group_id = admin_group.id
        edit_group, created = Group.objects.get_or_create(name='Editor')
        edit_group_id = edit_group.id
        read_group, created = Group.objects.get_or_create(name='Reader')
        read_group_id = read_group.id
        admin_add_perms = Permission.objects.all()
        admin_group.permissions.set(admin_add_perms)
        from django.db.models import Q
        cts = ContentType.objects.filter(
            Q(app_label='TEKDB') |
            Q(app_label='Relationships')
        )
        edit_add_perms = Permission.objects.filter(content_type__in=cts)
        edit_group.permissions.set(edit_add_perms)
        return {
            'admin_id': admin_group_id,
            'edit_id': edit_group_id,
            'read_id': read_group_id
        }

    def get_model_list(self):
        return [
            'lookupplanningunit',
            'lookuptribe',
            'lookuphabitat',
            'places',
            'lookupresourcegroup',
            'resources',
            'lookuppartused',
            'lookupcustomaryuse',
            'lookupseason',
            'lookuptiming',
            'placesresourceevents',
            'lookupparticipants',
            'lookuptechniques',
            'lookupactivity',
            'resourcesactivityevents',
            'people',
            'lookupreferencetype',
            'lookupauthortype',
            'citations',
            'placescitationevents',
            'currentversion',
            'lookuplocalitytype',
            'locality',
            'localitygisselections',
            'localityplaceresourceevent',
            'lookupmediatype',
            'lookupuserinfo',
            'media',
            'mediacitationevents',
            'placealtindigenousname',
            'placegisselections',
            'placesmediaevents',
            'placesresourcecitationevents',
            'placesresourcemediaevents',
            'resourceactivitycitationevents',
            'resourceactivitymediaevents',
            'resourcealtindigenousname',
            'resourceresourceevents',
            'resourcescitationevents',
            'resourcesmediaevents',
            'useraccess',
            'users',
        ]

    def create_sql_dict(self,infile):
        import string
        import re
        import shlex
        now = timezone.now()
        ############################################
        print("Generating insert script")
        ############################################
        insert_dict = {}
        model_list = self.get_model_list()
        group_id_dict = self.create_groups()
        # create lookup indexes (all 0)
        lookups = [
            # 'lookupplanningunit',     #Already has a numeric auto pk
            # 'lookuptribe',            #Already has a numeric auto pk
            'lookuphabitat',
            'lookupresourcegroup',
            'lookuppartused',
            'lookupcustomaryuse',
            'lookupseason',
            'lookuptiming',
            'lookupparticipants',
            'lookuptechniques',
            'lookupactivity',
            'lookupreferencetype',
            'lookupauthortype',
            'lookuplocalitytype',
            'lookupmediatype',
            # 'lookupuserinfo',         #Not used as an FK anywhere
        ]
        lookup_pks = {
            # 'lookupplanningunit': '"planningunitid"',   #Already has a numeric auto pk
            # 'lookuptribe': '"id"',                      #Already has a numeric auto pk
            'lookuphabitat': '"habitat"',
            'lookupresourcegroup': '"resourceclassificationgroup"',
            'lookuppartused': '"partused"',
            'lookupcustomaryuse': '"usedfor"',
            'lookupseason': '"season"',
            'lookuptiming': '"timing"',
            'lookupparticipants': '"participants"',
            'lookuptechniques': '"techniques"',
            'lookupactivity': '"activity"',
            'lookupreferencetype': '"documenttype"',
            'lookupauthortype': '"authortype"',
            'lookuplocalitytype': '"localitytype"',
            'lookupmediatype': '"mediatype"',
            # 'lookupuserinfo': '"pk"',                   #Not used as an FK anywhere
        }
        lookup_indices = {}
        # create lookup dict
        lookup_values = {}
        for lookup in lookups:
            lookup_indices[lookup] = 0
            lookup_values[lookup] = {
                'NULL': 'NULL'
            }
            # { 'Rocky Shore': 7 }
        # create list of models with lookup dependencies
        lookup_dependencies = {
            'citations': {
                '"referencetype"': 'lookupreferencetype',
                '"authortype"': 'lookupauthortype'
            },
            'locality': {
                '"localitytype"': 'lookuplocalitytype'
            },
            'media': {
                '"mediatype"': 'lookupmediatype'
            },
            'places': {
                '"primaryhabitat"': 'lookuphabitat',
            },
            'placesresourceevents': {
                '"partused"': 'lookuppartused',
                '"customaryuse"': 'lookupcustomaryuse',
                '"season"': 'lookupseason',
                '"timing"': 'lookuptiming'
            },
            'resources': {
                '"resourceclassificationgroup"': 'lookupresourcegroup',
            },
            'resourcesactivityevents': {
                '"partused"': 'lookuppartused',
                '"timing"': 'lookuptiming',
                '"participants"': 'lookupparticipants',
                '"technique"': 'lookuptechniques',
                '"activityshortdescription"': 'lookupactivity',
            }
        }
        for model in model_list:
            insert_dict[model] = {
                'inserts': [],
                'selects': [],
                'indices': [],
            }
        with open(infile) as rf:
            for line in rf:
                if "INSERT INTO \"" in line:
                    pattern = re.compile(r'INSERT INTO "(?P<table>.*)" \((?P<columns>.*)\) VALUES \((?P<values>.*)\);')
                    result = pattern.match(line)
                    model = result.groupdict()['table'].lower()
                    if model in model_list:
                        columns_lex = shlex.shlex(result.groupdict()['columns'])
                        columns_lex.quotes = '"'
                        columns = list(columns_lex)
                        columns = list(filter((',').__ne__, columns))
                        columns = [x.lower() for x in columns]
                        values = re.findall(r'(E\'".+?(?!\\)"\'|E\'.*?(?!\\)\'|.+?)(?:,\s|$)', result.groupdict()['values'])
                        if len(columns) != len(values):
                            import ipdb
                            ipdb.set_trace()
                            # This is left in place so that any detected mismatches can be fixed by hand now.
                            print(values)


                        if model == "users":
                            columns = columns + ['"is_superuser"', '"is_staff"', '"is_active"', '"date_joined"']
                            values = values + ["E'0'", "E'0'", "E'1'", "'%s'" % str(now)]
                        elif model == "useraccess":
                            accessLevelIndex = columns.index('"accesslevel"')
                            if values[accessLevelIndex] == "E'Administrator'" :
                                group_id = group_id_dict['admin_id']
                            elif values[accessLevelIndex] == "E'Editor'":
                                group_id = group_id_dict['edit_id']
                            else:
                                group_id = group_id_dict['read_id']
                            columns = columns + ['"group_id"']
                            values = values + [str(group_id)]
                        if model in lookups:
                            record_id = lookup_indices[model]
                            pk_field = lookup_pks[model]
                            columns = columns + ['"id"']
                            values = values + [str(record_id)]
                            try:
                                pk_index = columns.index(pk_field)
                            except Exception:
                                import ipdb
                                ipdb.set_trace()
                            pk_value = values[pk_index]
                            if not pk_value in lookup_values[model].keys():
                                lookup_values[model][pk_value] = str(record_id)
                                lookup_indices[model] = record_id + 1

                        insert_dict[model]['inserts'].append({
                            'table': model,
                            'columns': columns,
                            'values': values
                        })
                    else:
                        print('%s - not found in Model List.' % model)
                elif "SELECT setval(" in line:
                    # SELECT setval('"Users_UserID_seq"', MAX("UserID")) FROM "Users";
                    pattern = re.compile(r'SELECT setval\(\'(?P<sequence>.*)\', MAX\((?P<column>.*)\)\) FROM "(?P<table>.*)";')
                    result = pattern.match(line)
                    model = result.groupdict()['table'].lower()
                    if model in model_list:
                        column = result.groupdict()['column'].lower()
                        sequence = result.groupdict()['sequence'].lower()
                        insert_dict[model]['selects'].append({
                            'sequence': sequence,
                            'table': model,
                            'column': column
                        })
                    else:
                        print('%s - not found in Model List.' % model)
                elif "CREATE INDEX " in line:
                    # CREATE INDEX "Users_UserID" ON "Users" ("UserID");
                    pattern = re.compile(r'CREATE INDEX "(?P<index>.*)" ON "(?P<table>.*)"\s(?:USING\s.*\s)?\((?P<columns>.*)\);(?:\\n)?')
                    result = pattern.match(line)
                    if result:
                        model = result.groupdict()['table'].lower()
                        if model in model_list:
                            columns = result.groupdict()['columns'].lower()
                            index = result.groupdict()['index'].lower()
                            insert_dict[model]['indices'].append({
                                'index': index,
                                'table': model,
                                'columns': columns
                            })
                        else:
                            print('%s - not found in Model List.' % model)
                    # else:
                    #     print('Line does not match CREATE INDEX pattern: %s' % line)

        #TODO: when done:
        #TODO:      For each user:
        #TODO:          Check access-level and adjust 'is_superuser' and 'is_staff' accordingly
        #TODO:          or see that groups are appropriate

        for model in lookup_dependencies.keys():
            for insert_rec in insert_dict[model]['inserts']:
                for lookup in lookup_dependencies[model].keys():
                    # get index of lookup fk field
                    lookup_index = insert_rec['columns'].index(lookup)
                    # get old char pk value for fk lookup model
                    char_pk_value = insert_rec['values'][lookup_index]
                    # get model of lookup fk
                    lookup_model = lookup_dependencies[model][lookup]
                    # Check to be sure lookup_value exists and has an associated ID
                    if not char_pk_value in lookup_values[lookup_model].keys():
                        lookup_record_id = lookup_indices[lookup_model]
                        lookup_values[lookup_model][char_pk_value] = str(lookup_record_id)
                        lookup_indices[lookup_model] = lookup_record_id + 1
                        insert_dict[lookup_model]['inserts'].append({
                            'table': lookup_model,
                            'columns': ['"id"', lookup_pks[lookup_model]],
                            'values': [str(lookup_record_id), char_pk_value]
                        })
                    # get int pk value from old char pk value
                    lookup_id = lookup_values[lookup_model][char_pk_value]
                    insert_rec['values'][lookup_index] = lookup_id
        return insert_dict

    def create_insert_script(self, insert_script,insert_dict):
        model_list = self.get_model_list()
        with open(insert_script, "w") as wf:
            for model in model_list:
                for insert in insert_dict[model]['inserts']:
                    line = 'INSERT INTO "%s" (%s) VALUES (%s);\n' % (insert['table'], ', '.join(insert['columns']), ', '.join(insert['values']))
                    wf.write(line)
                for select in insert_dict[model]['selects']:
                    line = 'SELECT setval(\'%s\', MAX(%s)) FROM "%s";\n' % (select['sequence'], select['column'], select['table'])
                    wf.write(line)
                for index in insert_dict[model]['indices']:
                    line = 'CREATE INDEX "%s" ON "%s" (%s);\n' % (index['index'], index['table'], index['columns'])
                    wf.write(line)


    def get_app_list(self):
        return ['TEKDB', 'Lookup', 'Accounts', 'Relationships', 'explore']

    def revert_migrations(self, manage_py):
        ############################################
        print("Reverting migrations")
        ############################################
        for app_module in self.get_app_list():
            os.system("%s migrate --fake %s zero" % (manage_py, app_module))

    def delete_old_migrations(self, MANAGE_DIR):
        ############################################
        print("Deleting migration files...")
        ############################################
        from pathlib import Path
        for module in self.get_app_list():
            migrations_path = os.path.join(MANAGE_DIR,module,'migrations')
            migrations = Path(migrations_path)
            migration_files = [x for x in migrations.iterdir() if not x.name == '__init__.py' and not x.is_dir()]
            for migration_file in migration_files:
                try:
                    os.remove(str(migration_file))
                    print('%s deleted' % migration_file.name)
                except OSError as e:
                    pass

    def rebuild_db(self, dbname, manage_py):
        ############################################
        print("Dropping Database")
        ############################################
        import psycopg2
        db.connections.close_all()
        conn_psql = psycopg2.connect("dbname=postgres user=postgres")
        cur_psql = conn_psql.cursor()
        conn_psql.set_isolation_level(0)
        cur_psql.execute('DROP DATABASE if exists %s;' % dbname)
        print("Recreating Database")
        cur_psql.execute('CREATE DATABASE %s;' % dbname)
        cur_psql.close()
        conn_psql.close()

        ############################################
        print("Making updated migration files")
        ############################################
        os.system("%s makemigrations" % manage_py)

        ############################################
        print("Migrating database")
        ############################################
        os.system("%s migrate" % manage_py)

    def import_sql_data(self,import_output,import_error,dbname,insert_script):
        ############################################
        print("Transferring old data into new database")
        ############################################
        from subprocess import call
        stdout = open(import_output, 'wb')
        stderr = open(import_error, 'wb')
        call(['psql', '-U', 'postgres', '-d', dbname, '-f', insert_script], stdout=stdout, stderr=stderr)

        ############################################
        print('Setting up access privileges')
        ############################################
        from TEKDB.models import Users
        users = Users.objects.all()
        for user in users:
            user.set_password(user.password)
            if user.accesslevel.accesslevel == 'Administrator':
                user.is_superuser = True
                user.is_staff = True
            if user.accesslevel.accesslevel == 'Editor':
                user.is_staff = True
            user.save()

    def set_auto_pk_initial_values(self,import_output,import_error,dbname,update_script):
        ############################################
        print("Resetting AutoIncrement Values")
        ############################################
        from subprocess import call
        stdout = open(import_output, 'ab')
        stderr = open(import_error, 'ab')
        call(['psql', '-U', 'postgres', '-d', dbname, '-f', update_script], stdout=stdout, stderr=stderr)

    def handle(self, *args, **options):
        try:
            revert = os.path.join(MANAGE_DIR, options['revert'][0])
        except Exception:
            revert = False
        FILE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        MANAGE_DIR = os.path.normpath(os.path.join(FILE_DIR,os.pardir,os.pardir))
        infile = os.path.normpath(os.path.join(MANAGE_DIR, options['infile'][0]))
        insert_script = os.path.join(MANAGE_DIR, 'scripts','insert.sql')
        update_script = os.path.join(MANAGE_DIR, 'scripts','update_sequences.sql')
        import_output = os.path.join(MANAGE_DIR, 'scripts','import_output.txt')
        import_error = os.path.join(MANAGE_DIR, 'scripts','import_output.txt')
        manage_py = os.path.join(MANAGE_DIR, 'manage.py')
        if not os.path.exists(infile):
            print('File not found: %s' % infile)
            quit()

        if revert:
            self.revert_migrations(manage_py)
            self.delete_old_migrations(MANAGE_DIR)
        try:
            from TEKDB.settings import DATABASES
            dbname = DATABASES['default']['NAME']
        except Exception:
            dbname = 'tekdb'
            print('Failed to set DB name from Local Settings!')
            print('Enter c to contine, or type your desired dbname as `dbname = _____` hit enter, then c, then enter again.')
            import ipdb
            ipdb.set_trace()
        self.rebuild_db(dbname, manage_py)

        insert_dict = self.create_sql_dict(infile)
        self.create_insert_script(insert_script,insert_dict)

        self.import_sql_data(import_output,import_error,dbname,insert_script)

        self.set_auto_pk_initial_values(import_output,import_error,dbname,update_script)
        ############################################
        print("Import Complete")
        ############################################
